include::{mod-loc}attributes.adoc[]
:sectnums:
//Category: openshift-tutorial
// Type: assembly

[id="openshift-tutorial"] 
= Creating a {service-network} with two OpenShift clusters

[role="system:abstract"]
This tutorial demonstrates how to connect a frontend service on a OpenShift cluster with a backend service on a OpenShift cluster using the `skupper` command-line interface (CLI).

.Prerequisites

* Access to projects in two OpenShift clusters, `cluster-admin` access is not required.
* One of the OpenShift clusters must be addressable from the other cluster.

This tutorial shows how to connect the following namespaces:

* `west` - runs the frontend service and is typically a public cluster.
* `east` - runs the backend service.

include::index.adoc[tags=installing-cli]


// Type: procedure
[id="configuring-consoles"] 
== Configuring terminal sessions

[role="system:abstract"]
This procedure describes how to configure your terminal sessions to use configurations to avoid problems as you configure {skupper} on different clusters.

.Prerequisites

* The OpenShift CLI is installed.
See the https://access.redhat.com/documentation/en-us/openshift_container_platform/4.6/html-single/cli_tools/index#installing-openshift-cli[OpenShift CLI] documentation for more instructions on how to install `oc`.

NOTE: In OpenShift 4.6 and later, you can use the web terminal to perform the following procedure, as described in the https://docs.openshift.com/container-platform/4.5/web_console/odc-about-web-terminal.html[web terminal] documentation.

.Procedure

. Start a terminal session to work on the `west` namespace and set the `KUBECONFIG` environment variable:
+
----
$ export KUBECONFIG=$HOME/.kube/config-west
----
+
This session is referred to later as the _west_ terminal session.

. Start a terminal session to work on the `east` namespace and set the `KUBECONFIG` environment variable:
+
----
$ export KUBECONFIG=$HOME/.kube/config-east
----
+
This session is referred to later as the _east_ terminal session.

. In each terminal session, log into the OpenShift cluster, for example:
+
----
$ oc login
----

// Type: procedure
[id="installing-skupper"] 
== Installing the {service-network} router in both clusters


. In the west terminal session:

.. Create the `west` project (namespace):
+
----
$ oc new-project west 
----

.. Create the {service-network} router:
+
----
$ skupper init
----

. In the east terminal session:
.. Create the `east` project (namespace):
+
----
$ oc new-project east 
----

.. Create the {service-network} router:
+
----
$ skupper init
----

. To check either installation, enter the following and note the output:
+
----
$ skupper status

Skupper enabled for namespace '<project-name>'. It is not connected to any other sites.
----

// Type: procedure
[id="connecting-namespaces"] 
== Connecting namespaces to create a {service-network}

With the {service-network} routers installed, you can connect them together securely and allow service sharing across the {service-network}.

.Procedure

. In the west terminal session, create a connection token to allow connection to the west namespace:
+
----
$ skupper token create $HOME/secret.yaml
----
+
This command creates the `secret.yaml` file in your home directory, which you can use to create the secure connection.

. In the east terminal session, use the token to create a connection to the west namespace:
+
----
$ skupper link create $HOME/secret.yaml
----

. To check connection, enter the following command in either terminal session:
+
----
$ skupper status

Skupper is enabled for namespace "<project-name>" in interior mode. It is connected to 1 other site. It has no exposed services.
The site console url is:  https://<skupper-url>
The credentials for internal console-auth mode are held in secret: 'skupper-console-users'
----


// Type: procedure
[id="frontend"] 
== Creating the frontend service

The frontend service is a simple Python application that displays a message from the backend application.

.Procedure

Perform all tasks in the west terminal session:

. Deploy the frontend service:
+
----
$ oc create deployment hello-world-frontend --image quay.io/skupper/hello-world-frontend
----

. Expose the frontend deployment as a cluster service:
+
----
$ oc expose deployment hello-world-frontend --port 8080 --type LoadBalancer
----

. Create a route for the frontend:
+
----
$ oc expose svc/hello-world-frontend
----

. Check the frontend route:
.. Get the route details:
+
----
$  oc get routes
NAME                   HOST/PORT                                   
hello-world-frontend   <frontend-url>       
----
.. Navigate to the `<frontend-url>` value in your browser, you see a message similar to the following because the frontend cannot communicate with the backend yet:
+
----
Trouble! HTTPConnectionPool(host='hello-world-backend', port=8080): Max retries exceeded with url: /api/hello (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fbfcdf0d1d0>: Failed to establish a new connection: [Errno -2] Name or service not known'))
----
+
To resolve this situation, you must create the backend service and make it available on the {service-network}.

// Type: procedure
[id="backend"] 
== Creating the backend service and making it available on the {service-network}

The backend service runs in the `east` namespace and is not available on the {service-network} by default.
You use the `skupper` command to expose the service to all namespaces on the {service-network}.
The backend app is a simple Python application that passes a message to the frontend application.

.Procedure

Perform all tasks in the east terminal session:

. Deploy the backend service:
+
----
$ oc create deployment hello-world-backend --image quay.io/skupper/hello-world-backend
----

. Expose the backend service on the {service-network}:
+
----
$ skupper expose deployment hello-world-backend --port 8080 --protocol tcp
----

. Check the frontend route:
.. Get the route details:
+
----
$  oc get routes
NAME                   HOST/PORT                                   
hello-world-frontend   <frontend-url>       
----
.. Navigate to the `<frontend-url>` value in your browser, you see a message similar to the following showing that the connection with the backend is working:
+
----
I am the frontend.  The backend says 'Hello from hello-world-backend-78cd4d7d8c-plrr9 (1)'.
----

